// C64 Assembly Grammar using Pest

// Whitespace handling
WHITESPACE = _{ " " | "\t" }
NEWLINE = _{ "\n" | "\r\n" | "\r" }

// Not COMMENT - need to control where comments may occur.
comment = { ";" ~ (!NEWLINE ~ ANY)* }

// A program is a list of lines.
program = { SOI ~ (line)* ~ EOI }

// A line can have a label, an instruction or directive, and
// a comment, it always ends with a newline. Can be empty.
line = {
    label? ~ (instruction | directive)? ~ comment? ~ NEWLINE
}

// Labels
label = @{ label_name ~ ":" }
label_name = @{ ("_"* ~ ASCII_ALPHA_LOWER ~ (ASCII_ALPHANUMERIC | "_")*) | "*" }

// Instructions
instruction = { opcode ~ operand? }

// Opcode
opcode = @{ ASCII_ALPHA{3} }

// Operand encodes the addressing mode used.
operand = @{ 
    "#" ~ primary |                      // Immediate
    primary ~ ",x" |                     // Indexed with X
    primary ~ ",y" |                     // Indexed with Y
    "(" ~ primary ~ ")" |                // Indirect
    "(" ~ primary ~ ",x)" |              // Indexed indirect
    "(" ~ primary ~ "),y" |              // Indirect indexed
    primary                              // Absolute or Zero Page
}

// Directives
directive = { directive_name ~ (directive_arg)* }
// TODO this needs more structure
directive_arg = @{ (!NEWLINE ~ ANY)+ }
directive_name = @{ "." ~ ASCII_ALPHA+ }

// Expr
primary = { 
    number_literal | 
    "'" ~ char_literal ~ "'" |
    label_name |
    identifier |
    "(" ~ primary ~ ")" |
    "<" ~ primary | 			// lower nibble
    ">" ~ primary 			// upper nibble
}

// Generic identifier
identifier = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")+ }

// Literals
number_literal = @{ 
    "$" ~ hex_digit+ |                      // Hexadecimal
    "%" ~ bin_digit+ |                      // Binary
    ASCII_DIGIT+                            // Decimal
}
hex_digit = _{ ASCII_DIGIT | 'a'..'f' | 'A'..'F' }
bin_digit = _{ '0'..'1' }
char_literal = @{ ANY }

// Strings - not used yet
string_literal = ${ "\"" ~ inner_str ~ "\"" }
inner_str = @{ (!("\"" | "\\") ~ ANY)* ~ (escape ~ inner_str)? }
escape = @{ "\\" ~ ("\"" | "\\" | "n" | "r" | "t") }
